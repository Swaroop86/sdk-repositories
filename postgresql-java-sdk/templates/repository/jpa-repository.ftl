<#-- JPA Repository Template -->
<#-- Location: sdk-repositories/postgresql-java-sdk/templates/repository/jpa-repository.ftl -->
package ${package.repository};

import ${package.entity}.${entityClass};
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
<#if pagination>
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
</#if>
<#if primaryKeyType != "Long" && primaryKeyType != "Integer">
import ${primaryKeyImport};
</#if>

/**
 * Repository interface for ${entityClass} entity
 * Provides database operations for ${tableName} table
 * Generated by MCP PostgreSQL SDK
 * @author ${author!"MCP Generator"}
 * @since ${date}
 */
@Repository
public interface ${repositoryName} extends JpaRepository<${entityClass}, ${primaryKeyType}><#if specifications>, JpaSpecificationExecutor<${entityClass}></#if> {

<#-- Generate finder methods for unique fields -->
<#list fields as field>
<#if field.unique && !field.primaryKey>
    /**
     * Find ${entityClass} by ${field.name}
     * @param ${field.name} the ${field.name} to search for
     * @return Optional containing the entity if found
     */
    Optional<${entityClass}> findBy${field.name?cap_first}(${field.type} ${field.name});

    /**
     * Check if entity exists by ${field.name}
     * @param ${field.name} the ${field.name} to check
     * @return true if exists, false otherwise
     */
    boolean existsBy${field.name?cap_first}(${field.type} ${field.name});

</#if>
</#list>

<#-- Generate finder methods for indexed fields -->
<#list fields as field>
<#if field.indexed && !field.unique && !field.primaryKey>
    /**
     * Find all entities by ${field.name}
     * @param ${field.name} the ${field.name} to search for
     * @return List of entities
     */
    List<${entityClass}> findBy${field.name?cap_first}(${field.type} ${field.name});

<#if pagination>
    /**
     * Find all entities by ${field.name} with pagination
     * @param ${field.name} the ${field.name} to search for
     * @param pageable pagination information
     * @return Page of entities
     */
    Page<${entityClass}> findBy${field.name?cap_first}(${field.type} ${field.name}, Pageable pageable);
</#if>

</#if>
</#list>

<#-- Generate search methods for String fields -->
<#list fields as field>
<#if field.type == "String" && !field.unique>
    /**
     * Find entities where ${field.name} contains the given text (case-insensitive)
     * @param ${field.name} the text to search for
     * @return List of matching entities
     */
    List<${entityClass}> findBy${field.name?cap_first}ContainingIgnoreCase(String ${field.name});

    /**
     * Find entities where ${field.name} starts with the given text
     * @param ${field.name} the prefix to search for
     * @return List of matching entities
     */
    List<${entityClass}> findBy${field.name?cap_first}StartingWith(String ${field.name});

</#if>
</#list>

<#-- Generate methods for boolean fields -->
<#list fields as field>
<#if field.type == "Boolean" || field.type == "boolean">
    /**
     * Find all entities where ${field.name} is ${field.name}
     * @param ${field.name} the boolean value to filter by
     * @return List of entities
     */
    List<${entityClass}> findBy${field.name?cap_first}(${field.type} ${field.name});

</#if>
</#list>

<#-- Custom query methods -->
<#if customQueries??>
<#list customQueries as query>
    /**
     * ${query.description}
     */
    @Query("${query.jpql}")
    ${query.returnType} ${query.methodName}(<#list query.parameters as param>@Param("${param.name}") ${param.type} ${param.name}<#if param_has_next>, </#if></#list>);

</#list>
</#if>

<#-- Bulk operations -->
    /**
     * Delete all entities by IDs
     * @param ids list of IDs to delete
     * @return number of deleted entities
     */
    @Modifying
    @Transactional
    @Query("DELETE FROM ${entityClass} e WHERE e.${primaryKeyField!"id"} IN :ids")
    int deleteByIdIn(@Param("ids") List<${primaryKeyType}> ids);

<#-- Soft delete support if enabled -->
<#if softDelete>
    /**
     * Soft delete entity by ID
     * @param id the ID of entity to soft delete
     * @return number of affected rows
     */
    @Modifying
    @Transactional
    @Query("UPDATE ${entityClass} e SET e.deleted = true, e.deletedAt = CURRENT_TIMESTAMP WHERE e.${primaryKeyField!"id"} = :id")
    int softDeleteById(@Param("id") ${primaryKeyType} id);

    /**
     * Find all non-deleted entities
     * @return List of active entities
     */
    @Query("SELECT e FROM ${entityClass} e WHERE e.deleted = false")
    List<${entityClass}> findAllActive();

    /**
     * Find all non-deleted entities with pagination
     * @param pageable pagination information
     * @return Page of active entities
     */
    @Query("SELECT e FROM ${entityClass} e WHERE e.deleted = false")
    Page<${entityClass}> findAllActive(Pageable pageable);

</#if>

<#-- Auditing queries if audit fields are enabled -->
<#if auditFields>
    /**
     * Find entities created by user
     * @param createdBy username of creator
     * @return List of entities
     */
    List<${entityClass}> findByCreatedBy(String createdBy);

    /**
     * Find entities modified after specific date
     * @param date the date to compare
     * @return List of recently modified entities
     */
    @Query("SELECT e FROM ${entityClass} e WHERE e.updatedAt > :date ORDER BY e.updatedAt DESC")
    List<${entityClass}> findRecentlyModified(@Param("date") LocalDateTime date);

</#if>

<#-- Statistics and aggregation queries -->
    /**
     * Count entities by specific criteria
     * @return count of entities
     */
    @Query("SELECT COUNT(e) FROM ${entityClass} e")
    long countAll();

<#-- Native query example -->
<#if nativeQueries>
    /**
     * Example of native PostgreSQL query
     * Finds entities using PostgreSQL-specific features
     */
    @Query(value = "SELECT * FROM ${tableName} WHERE to_tsvector('english', name) @@ to_tsquery('english', :searchTerm)", 
           nativeQuery = true)
    List<${entityClass}> fullTextSearch(@Param("searchTerm") String searchTerm);
</#if>

<#-- Projection support -->
<#if projections??>
    /**
     * Find all entities returning only specific fields
     * @return List of projections
     */
    @Query("SELECT new ${package.dto}.${entityClass}Summary(e.${primaryKeyField!"id"}, e.name) FROM ${entityClass} e")
    List<${entityClass}Summary> findAllSummaries();
</#if>
}