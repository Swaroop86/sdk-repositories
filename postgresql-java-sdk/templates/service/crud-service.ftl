<#-- CRUD Service Template -->
<#-- Location: sdk-repositories/postgresql-java-sdk/templates/service/crud-service.ftl -->
package ${package.service};

import ${package.entity}.${entityClass};
import ${package.repository}.${repositoryName};
<#if dto>
import ${package.dto.request}.Create${entityClass}Request;
import ${package.dto.request}.Update${entityClass}Request;
import ${package.dto.response}.${entityClass}Response;
import ${package.mapper}.${entityClass}Mapper;
</#if>
<#if exceptions>
import ${package.exception}.ResourceNotFoundException;
import ${package.exception}.BusinessException;
</#if>

<#if lombok>
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
</#if>
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
<#if caching>
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
</#if>
<#if pagination>
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
</#if>
<#if specifications>
import org.springframework.data.jpa.domain.Specification;
</#if>

import java.util.List;
import java.util.Optional;
<#if primaryKeyType != "Long" && primaryKeyType != "Integer">
import ${primaryKeyImport};
</#if>

/**
 * Service class for ${entityClass} entity
 * Handles business logic for ${tableName} operations
 * Generated by MCP PostgreSQL SDK
 * @author ${author!"MCP Generator"}
 * @since ${date}
 */
@Service
<#if lombok>
@RequiredArgsConstructor
@Slf4j
</#if>
@Transactional(readOnly = true)
public class ${serviceName} {

<#if !lombok>
    private final ${repositoryName} repository;
    <#if dto>
    private final ${entityClass}Mapper mapper;
    </#if>

    public ${serviceName}(${repositoryName} repository<#if dto>, ${entityClass}Mapper mapper</#if>) {
        this.repository = repository;
        <#if dto>
        this.mapper = mapper;
        </#if>
    }
<#else>
    private final ${repositoryName} repository;
    <#if dto>
    private final ${entityClass}Mapper mapper;
    </#if>
</#if>

    /**
     * Create a new ${entityClass}
     * @param <#if dto>request the creation request<#else>entity the entity to create</#if>
     * @return the created entity
     */
    @Transactional
    <#if caching>
    @CacheEvict(value = "${entityClass?lower_case}Cache", allEntries = true)
    </#if>
    public <#if dto>${entityClass}Response<#else>${entityClass}</#if> create(<#if dto>Create${entityClass}Request request<#else>${entityClass} entity</#if>) {
        <#if lombok>log.debug("Creating new ${entityClass}: {}", <#if dto>request<#else>entity</#if>);</#if>
        
        <#if dto>
        // Validate request
        validateCreateRequest(request);
        
        // Convert DTO to entity
        ${entityClass} entity = mapper.toEntity(request);
        </#if>
        
        <#if businessRules??>
        // Apply business rules
        <#list businessRules.onCreate as rule>
        ${rule}
        </#list>
        </#if>
        
        // Save entity
        ${entityClass} saved = repository.save(entity);
        
        <#if lombok>log.info("Created ${entityClass} with ID: {}", saved.get${primaryKeyField?cap_first!"Id"}());</#if>
        
        <#if dto>
        return mapper.toResponse(saved);
        <#else>
        return saved;
        </#if>
    }

    /**
     * Find ${entityClass} by ID
     * @param id the entity ID
     * @return the entity if found
     */
    <#if caching>
    @Cacheable(value = "${entityClass?lower_case}Cache", key = "#id")
    </#if>
    public Optional<<#if dto>${entityClass}Response<#else>${entityClass}</#if>> findById(${primaryKeyType} id) {
        <#if lombok>log.debug("Finding ${entityClass} by ID: {}", id);</#if>
        
        <#if dto>
        return repository.findById(id)
            .map(mapper::toResponse);
        <#else>
        return repository.findById(id);
        </#if>
    }

    /**
     * Get ${entityClass} by ID (throws exception if not found)
     * @param id the entity ID
     * @return the entity
     * @throws ResourceNotFoundException if entity not found
     */
    public <#if dto>${entityClass}Response<#else>${entityClass}</#if> getById(${primaryKeyType} id) {
        <#if lombok>log.debug("Getting ${entityClass} by ID: {}", id);</#if>
        
        ${entityClass} entity = repository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("${entityClass} not found with ID: " + id));
        
        <#if dto>
        return mapper.toResponse(entity);
        <#else>
        return entity;
        </#if>
    }

    /**
     * Find all ${entityClass} entities
     * @return list of all entities
     */
    <#if caching>
    @Cacheable(value = "${entityClass?lower_case}Cache")
    </#if>
    public List<<#if dto>${entityClass}Response<#else>${entityClass}</#if>> findAll() {
        <#if lombok>log.debug("Finding all ${entityClass} entities");</#if>
        
        List<${entityClass}> entities = repository.findAll();
        
        <#if dto>
        return mapper.toResponseList(entities);
        <#else>
        return entities;
        </#if>
    }

<#if pagination>
    /**
     * Find all ${entityClass} entities with pagination
     * @param pageable pagination parameters
     * @return page of entities
     */
    public Page<<#if dto>${entityClass}Response<#else>${entityClass}</#if>> findAll(Pageable pageable) {
        <#if lombok>log.debug("Finding ${entityClass} entities with pagination: {}", pageable);</#if>
        
        Page<${entityClass}> page = repository.findAll(pageable);
        
        <#if dto>
        return page.map(mapper::toResponse);
        <#else>
        return page;
        </#if>
    }

    /**
     * Find all ${entityClass} entities with sorting
     * @param sort sorting parameters
     * @return sorted list of entities
     */
    public List<<#if dto>${entityClass}Response<#else>${entityClass}</#if>> findAll(Sort sort) {
        <#if lombok>log.debug("Finding ${entityClass} entities with sorting: {}", sort);</#if>
        
        List<${entityClass}> entities = repository.findAll(sort);
        
        <#if dto>
        return mapper.toResponseList(entities);
        <#else>
        return entities;
        </#if>
    }
</#if>

<#if specifications>
    /**
     * Find ${entityClass} entities by specification
     * @param spec the specification to use
     * @return list of matching entities
     */
    public List<<#if dto>${entityClass}Response<#else>${entityClass}</#if>> findAll(Specification<${entityClass}> spec) {
        <#if lombok>log.debug("Finding ${entityClass} entities with specification");</#if>
        
        List<${entityClass}> entities = repository.findAll(spec);
        
        <#if dto>
        return mapper.toResponseList(entities);
        <#else>
        return entities;
        </#if>
    }

    /**
     * Find ${entityClass} entities by specification with pagination
     * @param spec the specification to use
     * @param pageable pagination parameters
     * @return page of matching entities
     */
    public Page<<#if dto>${entityClass}Response<#else>${entityClass}</#if>> findAll(Specification<${entityClass}> spec, Pageable pageable) {
        <#if lombok>log.debug("Finding ${entityClass} entities with specification and pagination");</#if>
        
        Page<${entityClass}> page = repository.findAll(spec, pageable);
        
        <#if dto>
        return page.map(mapper::toResponse);
        <#else>
        return page;
        </#if>
    }
</#if>

    /**
     * Update existing ${entityClass}
     * @param id the entity ID
     * @param <#if dto>request the update request<#else>entity the updated entity</#if>
     * @return the updated entity
     */
    @Transactional
    <#if caching>
    @CachePut(value = "${entityClass?lower_case}Cache", key = "#id")
    </#if>
    public <#if dto>${entityClass}Response<#else>${entityClass}</#if> update(${primaryKeyType} id, <#if dto>Update${entityClass}Request request<#else>${entityClass} entity</#if>) {
        <#if lombok>log.debug("Updating ${entityClass} with ID: {}", id);</#if>
        
        // Find existing entity
        ${entityClass} existing = repository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("${entityClass} not found with ID: " + id));
        
        <#if dto>
        // Validate update request
        validateUpdateRequest(request, existing);
        
        // Update entity fields
        mapper.updateEntity(request, existing);
        <#else>
        // Set the ID to ensure update
        entity.set${primaryKeyField?cap_first!"Id"}(id);
        </#if>
        
        <#if businessRules??>
        // Apply business rules
        <#list businessRules.onUpdate as rule>
        ${rule}
        </#list>
        </#if>
        
        // Save updated entity
        ${entityClass} updated = repository.save(<#if dto>existing<#else>entity</#if>);
        
        <#if lombok>log.info("Updated ${entityClass} with ID: {}", id);</#if>
        
        <#if dto>
        return mapper.toResponse(updated);
        <#else>
        return updated;
        </#if>
    }

    /**
     * Delete ${entityClass} by ID
     * @param id the entity ID
     */
    @Transactional
    <#if caching>
    @CacheEvict(value = "${entityClass?lower_case}Cache", key = "#id")
    </#if>
    public void deleteById(${primaryKeyType} id) {
        <#if lombok>log.debug("Deleting ${entityClass} with ID: {}", id);</#if>
        
        // Check if entity exists
        if (!repository.existsById(id)) {
            throw new ResourceNotFoundException("${entityClass} not found with ID: " + id);
        }
        
        <#if businessRules??>
        // Apply business rules before deletion
        <#list businessRules.onDelete as rule>
        ${rule}
        </#list>
        </#if>
        
        repository.deleteById(id);
        
        <#if lombok>log.info("Deleted ${entityClass} with ID: {}", id);</#if>
    }

    /**
     * Delete multiple ${entityClass} entities by IDs
     * @param ids list of entity IDs
     * @return number of deleted entities
     */
    @Transactional
    <#if caching>
    @CacheEvict(value = "${entityClass?lower_case}Cache", allEntries = true)
    </#if>
    public int deleteByIds(List<${primaryKeyType}> ids) {
        <#if lombok>log.debug("Deleting ${entityClass} entities with IDs: {}", ids);</#if>
        
        int deleted = repository.deleteByIdIn(ids);
        
        <#if lombok>log.info("Deleted {} ${entityClass} entities", deleted);</#if>
        
        return deleted;
    }

    /**
     * Check if ${entityClass} exists by ID
     * @param id the entity ID
     * @return true if exists, false otherwise
     */
    public boolean existsById(${primaryKeyType} id) {
        return repository.existsById(id);
    }

    /**
     * Count all ${entityClass} entities
     * @return total count
     */
    public long count() {
        return repository.count();
    }

<#if specifications>
    /**
     * Count ${entityClass} entities by specification
     * @param spec the specification to use
     * @return count of matching entities
     */
    public long count(Specification<${entityClass}> spec) {
        return repository.count(spec);
    }
</#if>

<#-- Add custom service methods for unique fields -->
<#list fields as field>
<#if field.unique && !field.primaryKey>
    /**
     * Find ${entityClass} by ${field.name}
     * @param ${field.name} the ${field.name} to search for
     * @return the entity if found
     */
    public Optional<<#if dto>${entityClass}Response<#else>${entityClass}</#if>> findBy${field.name?cap_first}(${field.type} ${field.name}) {
        <#if lombok>log.debug("Finding ${entityClass} by ${field.name}: {}", ${field.name});</#if>
        
        <#if dto>
        return repository.findBy${field.name?cap_first}(${field.name})
            .map(mapper::toResponse);
        <#else>
        return repository.findBy${field.name?cap_first}(${field.name});
        </#if>
    }

    /**
     * Check if ${entityClass} exists by ${field.name}
     * @param ${field.name} the ${field.name} to check
     * @return true if exists, false otherwise
     */
    public boolean existsBy${field.name?cap_first}(${field.type} ${field.name}) {
        return repository.existsBy${field.name?cap_first}(${field.name});
    }
</#if>
</#list>

<#if dto>
    // Validation methods
    private void validateCreateRequest(Create${entityClass}Request request) {
        // Add custom validation logic here
        <#list fields as field>
        <#if field.unique && !field.primaryKey>
        if (repository.existsBy${field.name?cap_first}(request.get${field.name?cap_first}())) {
            throw new BusinessException("${entityClass} with ${field.name} '" + request.get${field.name?cap_first}() + "' already exists");
        }
        </#if>
        </#list>
    }

    private void validateUpdateRequest(Update${entityClass}Request request, ${entityClass} existing) {
        // Add custom validation logic here
        <#list fields as field>
        <#if field.unique && !field.primaryKey>
        if (!existing.get${field.name?cap_first}().equals(request.get${field.name?cap_first}()) 
            && repository.existsBy${field.name?cap_first}(request.get${field.name?cap_first}())) {
            throw new BusinessException("${entityClass} with ${field.name} '" + request.get${field.name?cap_first}() + "' already exists");
        }
        </#if>
        </#list>
    }
</#if>
}