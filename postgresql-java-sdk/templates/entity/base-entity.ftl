<#-- Base Entity Template -->
<#-- Location: sdk-repositories/postgresql-java-sdk/templates/entity/base-entity.ftl -->
package ${package.entity};

<#-- Import statements -->
import jakarta.persistence.*;
<#if validation>
import jakarta.validation.constraints.*;
</#if>
<#if lombok>
import lombok.*;
</#if>
<#-- Type imports -->
<#list imports as import>
import ${import};
</#list>
import java.io.Serializable;

/**
 * Entity class for ${tableName} table
 * Generated by MCP PostgreSQL SDK
 * @author ${author!"MCP Generator"}
 * @since ${date}
 */
@Entity
@Table(name = "${tableName}"<#if schema??>, schema = "${schema}"</#if>)
<#if lombok>
@Getter
@Setter
@ToString
@NoArgsConstructor
@AllArgsConstructor
@Builder
</#if>
<#if equalHashCode>
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
</#if>
<#-- Table indexes -->
<#if indexes??>
<#list indexes as index>
@Table(indexes = {
    @Index(name = "${index.name}", columnList = "${index.columns}")
})
</#list>
</#if>
<#-- Named queries if any -->
<#if namedQueries??>
@NamedQueries({
<#list namedQueries as query>
    @NamedQuery(name = "${query.name}", query = "${query.query}")<#if query_has_next>,</#if>
</#list>
})
</#if>
public class ${className} implements Serializable {

    private static final long serialVersionUID = 1L;

<#-- Fields -->
<#list fields as field>
    <#-- Primary Key -->
    <#if field.primaryKey>
    @Id
    <#if field.generationType??>
    @GeneratedValue(strategy = GenerationType.${field.generationType})
    <#if field.generationType == "SEQUENCE">
    @SequenceGenerator(name = "${tableName}_seq", sequenceName = "${tableName}_sequence", allocationSize = 1)
    </#if>
    </#if>
    <#if equalHashCode>
    @EqualsAndHashCode.Include
    </#if>
    </#if>
    
    <#-- Column definition -->
    @Column(name = "${field.columnName}"<#if !field.nullable>, nullable = false</#if><#if field.unique>, unique = true</#if><#if field.length??>, length = ${field.length}</#if><#if field.precision??>, precision = ${field.precision}</#if><#if field.scale??>, scale = ${field.scale}</#if><#if field.columnDefinition??>, columnDefinition = "${field.columnDefinition}"</#if><#if field.insertable??>, insertable = ${field.insertable?c}</#if><#if field.updatable??>, updatable = ${field.updatable?c}</#if>)
    
    <#-- Validation annotations -->
    <#if validation && !field.primaryKey>
        <#if !field.nullable>
    @NotNull(message = "${field.name} is required")
        </#if>
        <#if field.type == "String">
            <#if field.length??>
    @Size(max = ${field.length}, message = "${field.name} must not exceed ${field.length} characters")
            </#if>
            <#if field.email?? && field.email>
    @Email(message = "Please provide a valid email address")
            </#if>
            <#if field.pattern??>
    @Pattern(regexp = "${field.pattern}", message = "${field.patternMessage!"Invalid format"}")
            </#if>
            <#if field.notBlank?? && field.notBlank>
    @NotBlank(message = "${field.name} cannot be blank")
            </#if>
        </#if>
        <#if field.min?? || field.max??>
            <#if field.min?? && field.max??>
    @Range(min = ${field.min}, max = ${field.max}, message = "${field.name} must be between ${field.min} and ${field.max}")
            <#elseif field.min??>
    @Min(value = ${field.min}, message = "${field.name} must be at least ${field.min}")
            <#elseif field.max??>
    @Max(value = ${field.max}, message = "${field.name} must not exceed ${field.max}")
            </#if>
        </#if>
        <#if field.positive?? && field.positive>
    @Positive(message = "${field.name} must be positive")
        </#if>
        <#if field.positiveOrZero?? && field.positiveOrZero>
    @PositiveOrZero(message = "${field.name} must be positive or zero")
        </#if>
        <#if field.negative?? && field.negative>
    @Negative(message = "${field.name} must be negative")
        </#if>
        <#if field.future?? && field.future>
    @Future(message = "${field.name} must be a future date")
        </#if>
        <#if field.past?? && field.past>
    @Past(message = "${field.name} must be a past date")
        </#if>
    </#if>
    
    <#-- Enumerated annotation -->
    <#if field.enumerated??>
    @Enumerated(EnumType.${field.enumType!"STRING"})
    </#if>
    
    <#-- Temporal annotation for older Date types -->
    <#if field.temporal??>
    @Temporal(TemporalType.${field.temporalType})
    </#if>
    
    <#-- Lob annotation for large objects -->
    <#if field.lob?? && field.lob>
    @Lob
    </#if>
    
    <#-- Type annotation for JSON columns -->
    <#if field.jsonType?? && field.jsonType>
    @Type(type = "json")
    @Column(columnDefinition = "jsonb")
    </#if>
    
    private ${field.type} ${field.name}<#if field.defaultValue??> = ${field.defaultValue}</#if>;

</#list>

<#-- Relationships -->
<#if relationships??>
<#list relationships as rel>
    <#-- OneToMany -->
    <#if rel.type == "OneToMany">
    @OneToMany(mappedBy = "${rel.mappedBy}", cascade = CascadeType.${rel.cascade!"ALL"}, fetch = FetchType.${rel.fetch!"LAZY"}<#if rel.orphanRemoval??>, orphanRemoval = ${rel.orphanRemoval?c}</#if>)
    private ${rel.collectionType!"List"}<${rel.targetEntity}> ${rel.fieldName};
    </#if>
    
    <#-- ManyToOne -->
    <#if rel.type == "ManyToOne">
    @ManyToOne(cascade = CascadeType.${rel.cascade!"MERGE"}, fetch = FetchType.${rel.fetch!"LAZY"}<#if rel.optional??>, optional = ${rel.optional?c}</#if>)
    @JoinColumn(name = "${rel.joinColumn}", referencedColumnName = "${rel.referencedColumn!"id"}"<#if !rel.nullable>, nullable = false</#if>)
    private ${rel.targetEntity} ${rel.fieldName};
    </#if>
    
    <#-- OneToOne -->
    <#if rel.type == "OneToOne">
    @OneToOne(cascade = CascadeType.${rel.cascade!"ALL"}, fetch = FetchType.${rel.fetch!"LAZY"}<#if rel.optional??>, optional = ${rel.optional?c}</#if>)
    <#if rel.joinColumn??>
    @JoinColumn(name = "${rel.joinColumn}", referencedColumnName = "${rel.referencedColumn!"id"}"<#if !rel.nullable>, nullable = false</#if>)
    <#else>
    @PrimaryKeyJoinColumn
    </#if>
    private ${rel.targetEntity} ${rel.fieldName};
    </#if>
    
    <#-- ManyToMany -->
    <#if rel.type == "ManyToMany">
    @ManyToMany(cascade = CascadeType.${rel.cascade!"MERGE"}, fetch = FetchType.${rel.fetch!"LAZY"})
    @JoinTable(
        name = "${rel.joinTable}",
        joinColumns = @JoinColumn(name = "${rel.joinColumn}"),
        inverseJoinColumns = @JoinColumn(name = "${rel.inverseJoinColumn}")
    )
    private ${rel.collectionType!"Set"}<${rel.targetEntity}> ${rel.fieldName};
    </#if>

</#list>
</#if>

<#-- Constructors if not using Lombok -->
<#if !lombok>
    /**
     * Default constructor
     */
    public ${className}() {
        // Default constructor
    }

    /**
     * Constructor with all fields
     */
    public ${className}(<#list fields as field>${field.type} ${field.name}<#if field_has_next>, </#if></#list>) {
        <#list fields as field>
        this.${field.name} = ${field.name};
        </#list>
    }

    <#-- Getters and Setters -->
    <#list fields as field>
    /**
     * Get ${field.name}
     * @return ${field.type}
     */
    public ${field.type} <#if field.type == "Boolean" || field.type == "boolean">is<#else>get</#if>${field.name?cap_first}() {
        return ${field.name};
    }

    /**
     * Set ${field.name}
     * @param ${field.name} the ${field.name} to set
     */
    public void set${field.name?cap_first}(${field.type} ${field.name}) {
        this.${field.name} = ${field.name};
    }

    </#list>
    
    <#-- toString -->
    @Override
    public String toString() {
        return "${className}{" +
            <#list fields as field>
            "${field.name}=" + ${field.name}<#if field_has_next> + ", " +<#else> +</#if>
            </#list>
            '}';
    }
    
    <#-- equals and hashCode for primary key -->
    <#if equalHashCode>
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ${className})) return false;
        ${className} that = (${className}) o;
        <#list fields as field>
        <#if field.primaryKey>
        return Objects.equals(${field.name}, that.${field.name});
        </#if>
        </#list>
    }

    @Override
    public int hashCode() {
        <#list fields as field>
        <#if field.primaryKey>
        return Objects.hash(${field.name});
        </#if>
        </#list>
    }
    </#if>
</#if>

<#-- Custom methods -->
<#if customMethods??>
    // Custom methods
    <#list customMethods as method>
    ${method}
    </#list>
</#if>

<#-- Lifecycle callbacks -->
<#if lifecycleCallbacks??>
    <#if lifecycleCallbacks.prePersist>
    @PrePersist
    protected void onCreate() {
        // Called before entity is persisted
        ${lifecycleCallbacks.prePersist}
    }
    </#if>
    
    <#if lifecycleCallbacks.postPersist>
    @PostPersist
    protected void onPersist() {
        // Called after entity is persisted
        ${lifecycleCallbacks.postPersist}
    }
    </#if>
    
    <#if lifecycleCallbacks.preUpdate>
    @PreUpdate
    protected void onUpdate() {
        // Called before entity is updated
        ${lifecycleCallbacks.preUpdate}
    }
    </#if>
    
    <#if lifecycleCallbacks.postUpdate>
    @PostUpdate
    protected void onPostUpdate() {
        // Called after entity is updated
        ${lifecycleCallbacks.postUpdate}
    }
    </#if>
    
    <#if lifecycleCallbacks.preRemove>
    @PreRemove
    protected void onRemove() {
        // Called before entity is removed
        ${lifecycleCallbacks.preRemove}
    }
    </#if>
</#if>
}